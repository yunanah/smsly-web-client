{"version":3,"file":"vue-scroll-picker.es.js","sources":["../src/components/picker.ts","../src/index.ts"],"sourcesContent":["import { defineComponent, PropType, h, renderSlot, VNode } from 'vue'\n\n\nfunction debounce<TFunc extends Function>(handle: TFunc, delay = 83): TFunc { // eslint-disable-line @typescript-eslint/ban-types\n  let timeout = null as any\n  return function (this: any) {\n    if (timeout) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n    const self = this // eslint-disable-line no-invalid-this,@typescript-eslint/no-this-alias\n    const args = arguments // eslint-disable-line prefer-rest-params\n    timeout = setTimeout(() => handle.apply(self, args), delay)\n  } as any as TFunc\n}\n\nfunction getBoundingClientCenterY(elem: HTMLElement) {\n  const { top, bottom } = elem.getBoundingClientRect()\n  return (top + bottom) / 2\n}\n\nfunction normalizeOptions(options: ScrollPickerOptionable[]): ScrollPickerOption[] {\n  return options.map((option) => {\n    switch (typeof option) {\n      case 'string': {\n        return { value: option, name: option }\n      }\n      case 'number':\n      case 'boolean': {\n        return { value: option, name: `${option}` }\n      }\n    }\n    return option\n  })\n}\n\nfunction isTouchEvent(event: any): event is TouchEvent {\n  return event.changedTouches || event.touches\n}\n\nfunction getEventXY(event: TouchEvent | MouseEvent): { clientX: number, clientY: number } {\n  if (isTouchEvent(event)) {\n    return event.changedTouches[0] || event.touches[0]\n  }\n  return event\n}\n\ntype MouseWheelEvent = MouseEvent & { deltaY: number }\n\nexport interface ScrollPickerOption {\n  name: string\n  value: any\n}\n\nexport type ScrollPickerOptionable = string | number | boolean | ScrollPickerOption\n\nexport default defineComponent({\n  props: {\n    modelValue: null,\n    options: {\n      type: Array as PropType<ScrollPickerOptionable[]>,\n      default: () => [],\n    },\n    dragSensitivity: {\n      type: Number,\n      default: 1.7,\n    },\n    touchSensitivity: {\n      type: Number,\n      default: 1.7,\n    },\n    scrollSensitivity: {\n      type: Number,\n      default: 1,\n    },\n    empty: {\n      type: String,\n      default: 'No Items',\n    },\n    placeholder: {\n      type: String,\n      default: null,\n    },\n  },\n  data() {\n    const internalOptions = normalizeOptions(this.options)\n\n    let internalIndex = internalOptions.findIndex(option => option.value == this.modelValue)\n    if (internalIndex === -1 && !this.placeholder && !this.$slots.placeholder && this.options.length > 0) {\n      internalIndex = 0\n    }\n    const internalValue = internalOptions[internalIndex]?.value ?? null\n\n    return {\n      refItems: [] as HTMLDivElement[],\n\n      internalOptions,\n      internalIndex,\n      internalValue,\n\n      pivots: [] as number[],\n      pivotsMin: 0,\n      pivotsMax: 0,\n\n      scroll: null as number | null,\n      scrollOffsetTop: 0,\n      scrollMin: 0,\n      scrollMax: 0,\n\n      transitioning: false,\n      transitionTimer: null as any | null,\n\n      start: null as [scroll: number, clientY: number] | null,\n\n      isMouseDown: false,\n      isDragging: false,\n    }\n  },\n  beforeUpdate() {\n    this.refItems = []\n  },\n  mounted() {\n    this.calculatePivots()\n    this.scroll = this.findScrollByIndex(this.internalIndex)\n    if (this.internalValue !== this.modelValue) {\n      this.$emit('update:modelValue', this.internalValue)\n    }\n\n    const $el = this.$el as HTMLDivElement\n\n    $el.addEventListener('touchstart', this.onStart)\n    $el.addEventListener('touchmove', this.onMove)\n    $el.addEventListener('touchend', this.onEnd)\n    $el.addEventListener('touchcancel', this.onCancel)\n\n    $el.addEventListener('mousewheel', this.onWheel as any)\n    $el.addEventListener('DOMMouseScroll', this.onWheel as any)\n    $el.addEventListener('wheel', this.onWheel)\n    $el.addEventListener('mousedown', this.onStart)\n    $el.addEventListener('mousemove', this.onMove)\n    $el.addEventListener('mouseup', this.onEnd)\n    $el.addEventListener('mouseleave', this.onCancel)\n\n  },\n  beforeUnmount() {\n    const $el = this.$el as HTMLDivElement\n\n    $el.removeEventListener('touchstart', this.onStart)\n    $el.removeEventListener('touchmove', this.onMove)\n    $el.removeEventListener('touchend', this.onEnd)\n    $el.removeEventListener('touchcancel', this.onCancel)\n\n    $el.removeEventListener('mousewheel', this.onWheel as any)\n    $el.removeEventListener('DOMMouseScroll', this.onWheel as any)\n    $el.removeEventListener('wheel', this.onWheel)\n    $el.removeEventListener('mousedown', this.onStart)\n    $el.removeEventListener('mousemove', this.onMove)\n    $el.removeEventListener('mouseup', this.onEnd)\n    $el.removeEventListener('mouseleave', this.onCancel)\n  },\n  watch: {\n    modelValue(value: any) {\n      if ((value === null || value === undefined) && this.hasPlaceholder) {\n        this.correction(-1)\n        return\n      }\n\n      const nextInternalIndex = this.internalOptions.findIndex((option) => option.value == value)\n      if (nextInternalIndex === -1) {\n        this.$emit('update:modelValue', this.internalValue)\n        return\n      }\n\n      if (this.internalIndex !== nextInternalIndex) {\n        this.correction(nextInternalIndex)\n      }\n    },\n    options: {\n      handler(options: ScrollPickerOptionable[]) {\n        const internalOptions = this.internalOptions = normalizeOptions(options)\n\n        let internalIndex = internalOptions.findIndex(option => option.value == this.modelValue)\n        if (internalIndex === -1 && !this.hasPlaceholder && this.options.length > 0) {\n          internalIndex = 0\n        }\n        const internalValue = internalOptions[internalIndex]?.value ?? null\n\n        this.$nextTick(() => {\n          this.calculatePivots()\n          this.scroll = this.findScrollByIndex(internalIndex)\n          this.internalIndex = internalIndex\n          if (this.internalValue !== internalValue) {\n            this.$emit('update:modelValue', this.internalValue = internalValue)\n          }\n        })\n      },\n      deep: true,\n    },\n  },\n  computed: {\n    hasPlaceholder(): boolean {\n      return !!(this.placeholder || this.$slots.placeholder)\n    },\n  },\n  methods: {\n    setRefItem(el: HTMLDivElement) {\n      this.refItems.push(el)\n    },\n    resize() {\n      this.$nextTick(() => {\n        this.calculatePivots()\n        this.scroll = this.findScrollByIndex(this.internalIndex)\n      })\n    },\n    calculatePivots() {\n      const $rotator = this.$refs.rotator as HTMLDivElement\n      const $layerSelection = this.$refs.layerSelection as HTMLDivElement\n\n      const rotatorTop = $rotator.getBoundingClientRect().top\n      const pivots = this.pivots = this.refItems.map((item) => getBoundingClientCenterY(item) - rotatorTop).sort((a, b) => a - b)\n      const pivotsMin = this.pivotsMin = Math.min(...pivots)\n      const pivotsMax = this.pivotsMax = Math.max(...pivots)\n\n      const scrollOffsetTop = this.scrollOffsetTop = $layerSelection.offsetTop + $layerSelection.offsetHeight / 2\n\n      this.scrollMin = scrollOffsetTop - pivotsMin\n      this.scrollMax = scrollOffsetTop - pivotsMax\n    },\n    sanitizeInternalIndex(index: number): number {\n      return Math.min(Math.max(index, this.hasPlaceholder ? -1 : 0), this.internalOptions.length - 1)\n    },\n    findIndexFromScroll(scroll: number): number {\n      let prevDiff = null as number | null\n      let pivotIndex = 0\n      this.pivots.forEach((pivot, i) => {\n        const diff = pivot + scroll - this.scrollOffsetTop\n        if (prevDiff === null || Math.abs(prevDiff) > Math.abs(diff)) {\n          pivotIndex = i\n          prevDiff = diff\n        }\n      })\n      if (this.hasPlaceholder || this.options.length === 0) {\n        return pivotIndex - 1\n      }\n      return pivotIndex\n    },\n    findScrollByIndex(index: number): number {\n      let pivotIndex = index\n      if (this.hasPlaceholder || this.options.length === 0) {\n        pivotIndex++\n      }\n      if (index > -1 && pivotIndex in this.pivots) {\n        return this.scrollOffsetTop - this.pivots[pivotIndex]\n      }\n      if (index >= this.pivots.length) {\n        return this.scrollOffsetTop - this.pivotsMax\n      }\n      return this.scrollOffsetTop - this.pivotsMin\n\n    },\n    onWheel(event: MouseWheelEvent) {\n      if (this.scroll! >= this.scrollMin && event.deltaY < 0) { return }\n      if (this.scroll! <= this.scrollMax && event.deltaY > 0) { return }\n      if (this.pivots.length === 1) { return }\n\n      event.preventDefault()\n\n      const nextDirInternalIndex = this.sanitizeInternalIndex(this.internalIndex + (event.deltaY > 0 ? 1 : -1))\n      const deltaMax = event.deltaY > 0\n        ? this.findScrollByIndex(nextDirInternalIndex - 1) - this.findScrollByIndex(nextDirInternalIndex)\n        : this.findScrollByIndex(nextDirInternalIndex) - this.findScrollByIndex(nextDirInternalIndex + 1)\n\n      const deltaY = Math.max(Math.min(event.deltaY, deltaMax), deltaMax * -1)\n\n      this.scroll = Math.min(Math.max(this.scroll! - deltaY * this.scrollSensitivity, this.scrollMax), this.scrollMin)\n\n      const nextInternalIndex = this.sanitizeInternalIndex(this.findIndexFromScroll(this.scroll))\n      const nextInternalValue = this.internalOptions[nextInternalIndex]?.value ?? null\n\n      this.internalIndex = nextInternalIndex\n      if (this.internalValue !== nextInternalValue) {\n        this.$emit('update:modelValue', this.internalValue = nextInternalValue)\n      }\n\n      this.onAfterWheel(() => {\n        this.correction(this.findIndexFromScroll(this.scroll!))\n      })\n    },\n    onAfterWheel: debounce((handler: () => void) => {\n      handler()\n    }, 200),\n    onStart(event: TouchEvent | MouseEvent) {\n      if (event.cancelable) {\n        event.preventDefault()\n      }\n\n      const { clientY } = getEventXY(event)\n      this.start = [this.scroll!, clientY]\n      if (!isTouchEvent(event)) {\n        this.isMouseDown = true\n      }\n      this.isDragging = false\n    },\n    onMove(event: TouchEvent | MouseEvent) {\n      if (event.cancelable) {\n        event.preventDefault()\n      }\n      if (!this.start) {\n        return\n      }\n      const { clientY } = getEventXY(event)\n      const diff = clientY - this.start[1]\n      if (Math.abs(diff) > 1.5) {\n        this.isDragging = true\n      }\n      this.scroll = this.start[0] + diff * (isTouchEvent(event) ? this.touchSensitivity : this.dragSensitivity)\n    },\n    onEnd(event: TouchEvent | MouseEvent) {\n      if (event.cancelable) {\n        event.preventDefault()\n      }\n      if (this.isDragging) {\n        this.correction(this.findIndexFromScroll(this.scroll!))\n      } else {\n        this.onClick(event)\n      }\n      this.start = null\n      this.isDragging = false\n      this.isMouseDown = false\n    },\n    onCancel(event: TouchEvent | MouseEvent) {\n      if (event.cancelable) {\n        event.preventDefault()\n      }\n      this.correction(this.findIndexFromScroll(this.scroll!))\n      this.start = null\n      this.isMouseDown = false\n      this.isDragging = false\n    },\n    onClick(event: TouchEvent | MouseEvent) {\n      const $layerTop = this.$refs.layerTop as HTMLDivElement\n      const $layerBottom = this.$refs.layerBottom as HTMLDivElement\n      const touchInfo = getEventXY(event)\n      const x = touchInfo.clientX\n      const y = touchInfo.clientY\n      const topRect = $layerTop.getBoundingClientRect()\n      const bottomRect = $layerBottom.getBoundingClientRect()\n\n      if (topRect.left <= x && x <= topRect.right && topRect.top <= y && y <= topRect.bottom) {\n        this.correction(this.internalIndex - 1)\n      } else if (bottomRect.left <= x && x <= bottomRect.right && bottomRect.top <= y && y <= bottomRect.bottom) {\n        this.correction(this.internalIndex + 1)\n      }\n    },\n    correction(index: number) {\n      const nextInternalIndex = this.sanitizeInternalIndex(index)\n      const nextInternalValue = this.internalOptions[nextInternalIndex]?.value ?? null\n      this.scroll = this.findScrollByIndex(nextInternalIndex)\n\n      this.transitioning = true\n      if (this.transitionTimer) {\n        clearTimeout(this.transitionTimer)\n        this.transitionTimer = null\n      }\n\n      this.transitionTimer = setTimeout(() => {\n        this.transitioning = false\n        this.transitionTimer = null\n\n        this.internalIndex = nextInternalIndex\n        if (this.internalValue !== nextInternalValue) {\n          this.$emit('update:modelValue', this.internalValue = nextInternalValue)\n        }\n      }, 100)\n    },\n  },\n  render() {\n    let nodes = [] as VNode[]\n    if (this.hasPlaceholder) {\n      nodes.push(h('div', {\n        class: [\n          'vue-scroll-picker-item',\n          'vue-scroll-picker-item-placeholder',\n          {\n            'vue-scroll-picker-item-selected': this.internalIndex === -1,\n          },\n        ],\n        ref: (el) => el && this.setRefItem(el as HTMLDivElement),\n      }, renderSlot(this.$slots, 'placeholder', { text: this.placeholder }, () => [\n        this.placeholder,\n      ])))\n    } else if (this.internalOptions.length === 0) {\n      nodes.push(h('div', {\n        class: [\n          'vue-scroll-picker-item',\n          'vue-scroll-picker-item-empty',\n          'vue-scroll-picker-item-selected',\n        ],\n        ref: (el) => el && this.setRefItem(el as HTMLDivElement),\n      }, renderSlot(this.$slots, 'empty', { text: this.empty }, () => [\n        this.empty,\n      ])))\n    }\n\n    nodes = nodes.concat(this.internalOptions.map((option, index) => {\n      return h('div', {\n        class: [\n          'vue-scroll-picker-item',\n          {\n            'vue-scroll-picker-item-selected': this.internalIndex === index,\n          },\n        ],\n        key: option.value,\n        ref: (el) => el && this.setRefItem(el as HTMLDivElement),\n      }, renderSlot(this.$slots, 'default', { option }, () => [\n        option.name,\n      ]))\n    }))\n    return h('div', {\n      class: [\n        'vue-scroll-picker',\n      ],\n    }, [\n      h('div', {\n        ref: 'rotator',\n        class: [\n          'vue-scroll-picker-rotator',\n          {\n            'vue-scroll-picker-rotator-transition': this.transitioning,\n          },\n        ],\n        style: typeof this.scroll === 'number' ? { top: `${this.scroll}px` } : {},\n      }, nodes),\n      h('div', { class: ['vue-scroll-picker-layer'] }, [\n        h('div', { class: ['vue-scroll-picker-layer-top'], ref: 'layerTop' }),\n        h('div', { class: ['vue-scroll-picker-layer-selection'], ref: 'layerSelection' }),\n        h('div', { class: ['vue-scroll-picker-layer-bottom'], ref: 'layerBottom' }),\n      ]),\n    ])\n  },\n})\n","import { App, Plugin } from 'vue'\n\nimport VueScrollPicker from './components/picker'\n\n\nexport function install(app: App) {\n  app.component('VueScrollPicker', VueScrollPicker)\n}\n\nif (typeof window !== 'undefined' && (window as any).Vue) {\n  install((window as any).Vue)\n}\n\nconst plugin: Plugin = {\n  install,\n}\n\nexport default plugin\n\n// re-define: https://github.com/vitejs/vite/issues/2117\nexport interface VueScrollPickerOption {\n  name: string\n  value: any\n}\n\nexport {\n  VueScrollPicker,\n}\n"],"names":["options","map","option","value","name","event","changedTouches","touches","isTouchEvent","defineComponent","props","modelValue","type","Array","default","dragSensitivity","Number","touchSensitivity","scrollSensitivity","empty","String","placeholder","[object Object]","internalOptions","normalizeOptions","this","internalIndex","findIndex","$slots","length","refItems","internalValue","pivots","pivotsMin","pivotsMax","scroll","scrollOffsetTop","scrollMin","scrollMax","transitioning","transitionTimer","start","isMouseDown","isDragging","calculatePivots","findScrollByIndex","$emit","$el","addEventListener","onStart","onMove","onEnd","onCancel","onWheel","removeEventListener","watch","hasPlaceholder","correction","nextInternalIndex","$nextTick","deep","computed","methods","el","push","$rotator","$refs","rotator","$layerSelection","layerSelection","rotatorTop","getBoundingClientRect","top","item","elem","bottom","getBoundingClientCenterY","sort","a","b","Math","min","max","offsetTop","offsetHeight","index","prevDiff","pivotIndex","forEach","pivot","i","diff","abs","deltaY","preventDefault","nextDirInternalIndex","sanitizeInternalIndex","deltaMax","findIndexFromScroll","nextInternalValue","onAfterWheel","handle","delay","timeout","self","args","arguments","setTimeout","apply","debounce","handler","cancelable","clientY","getEventXY","onClick","$layerTop","layerTop","$layerBottom","layerBottom","touchInfo","x","clientX","y","topRect","bottomRect","left","right","nodes","h","class","vue-scroll-picker-item-selected","ref","setRefItem","renderSlot","text","concat","key","vue-scroll-picker-rotator-transition","style","app","component","VueScrollPicker","window","Vue","plugin","install"],"mappings":"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"}